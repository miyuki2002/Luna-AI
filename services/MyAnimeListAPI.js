const axios = require("axios");
const logger = require("../utils/logger.js");
const { MessageEmbed } = require("discord.js");

class MyAnimeListAPI {
  constructor() {
    this.baseURL = "https://api.myanimelist.net/v2";
    this.clientId = process.env.MAL_CLIENT_ID;

    if (!this.clientId) {
      logger.warn(
        "API",
        "MAL_CLIENT_ID kh√¥ng ƒë∆∞·ª£c ƒë·∫∑t trong bi·∫øn m√¥i tr∆∞·ªùng. API MyAnimeList s·∫Ω kh√¥ng ho·∫°t ƒë·ªông."
      );
    }

    this.axiosInstance = axios.create({
      baseURL: this.baseURL,
      headers: {
        "X-MAL-CLIENT-ID": this.clientId,
      },
      timeout: 5000,
    });
  }

  /**
   * T√¨m ki·∫øm anime d·ª±a tr√™n t·ª´ kh√≥a
   * @param {string} query - T·ª´ kh√≥a t√¨m ki·∫øm
   * @param {number} limit - Gi·ªõi h·∫°n k·∫øt qu·∫£ (t·ªëi ƒëa 100)
   * @returns {Promise<Array>} - Danh s√°ch anime
   */
  async searchAnime(query, limit = 10) {
    try {
      logger.info("MAL API", `ƒêang t√¨m ki·∫øm anime v·ªõi t·ª´ kh√≥a: "${query}"`);

      const response = await this.axiosInstance.get("/anime", {
        params: {
          q: query,
          limit: limit,
          fields:
            "id,title,main_picture,synopsis,mean,rank,popularity,num_episodes,media_type,status,genres,start_season,studios",
        },
      });

      logger.info(
        "MAL API",
        `ƒê√£ t√¨m th·∫•y ${response.data.data.length} k·∫øt qu·∫£ cho "${query}"`
      );
      return response.data.data;
    } catch (error) {
      logger.error("MAL API", "L·ªói khi t√¨m ki·∫øm anime:", error.message);
      return [];
    }
  }

  /**
   * L·∫•y th√¥ng tin chi ti·∫øt v·ªÅ anime
   * @param {number} animeId - ID c·ªßa anime
   * @returns {Promise<Object>} - Chi ti·∫øt anime
   */
  async getAnimeDetails(animeId) {
    try {
      logger.info(
        "MAL API",
        `ƒêang l·∫•y th√¥ng tin chi ti·∫øt c·ªßa anime ID: ${animeId}`
      );

      const response = await this.axiosInstance.get(`/anime/${animeId}`, {
        params: {
          fields:
            "id,title,main_picture,alternative_titles,start_date,end_date,synopsis,mean,rank,popularity,num_list_users,num_scoring_users,nsfw,created_at,updated_at,media_type,status,genres,my_list_status,num_episodes,start_season,broadcast,source,average_episode_duration,rating,pictures,background,related_anime,related_manga,recommendations,studios,statistics",
        },
      });

      logger.info(
        "MAL API",
        `ƒê√£ l·∫•y th√¥ng tin chi ti·∫øt c·ªßa anime: ${response.data.title}`
      );
      return response.data;
    } catch (error) {
      logger.error(
        "MAL API",
        `L·ªói khi l·∫•y th√¥ng tin chi ti·∫øt anime ID ${animeId}:`,
        error.message
      );
      return null;
    }
  }

  /**
   * L·∫•y b·∫£ng x·∫øp h·∫°ng anime
   * @param {string} rankingType - Lo·∫°i b·∫£ng x·∫øp h·∫°ng (all, airing, upcoming, tv, ova, movie, special, bypopularity, favorite)
   * @param {number} limit - Gi·ªõi h·∫°n k·∫øt qu·∫£ (t·ªëi ƒëa 500)
   * @returns {Promise<Array>} - Danh s√°ch anime trong b·∫£ng x·∫øp h·∫°ng
   */
  async getAnimeRanking(rankingType = "all", limit = 10) {
    try {
      logger.info(
        "MAL API",
        `ƒêang l·∫•y b·∫£ng x·∫øp h·∫°ng anime lo·∫°i: ${rankingType}`
      );

      const response = await this.axiosInstance.get("/anime/ranking", {
        params: {
          ranking_type: rankingType,
          limit: limit,
          fields:
            "id,title,main_picture,mean,rank,popularity,num_episodes,media_type,status",
        },
      });

      logger.info(
        "MAL API",
        `ƒê√£ l·∫•y ${response.data.data.length} k·∫øt qu·∫£ t·ª´ b·∫£ng x·∫øp h·∫°ng ${rankingType}`
      );
      return response.data.data;
    } catch (error) {
      logger.error(
        "MAL API",
        `L·ªói khi l·∫•y b·∫£ng x·∫øp h·∫°ng anime lo·∫°i ${rankingType}:`,
        error.message
      );
      return [];
    }
  }

  /**
   * L·∫•y anime theo m√πa
   * @param {number} year - NƒÉm
   * @param {string} season - M√πa (winter, spring, summer, fall)
   * @param {number} limit - Gi·ªõi h·∫°n k·∫øt qu·∫£ (t·ªëi ƒëa 500)
   * @returns {Promise<Array>} - Danh s√°ch anime theo m√πa
   */
  async getSeasonalAnime(year, season, limit = 10) {
    try {
      logger.info("MAL API", `ƒêang l·∫•y anime m√πa ${season} nƒÉm ${year}`);

      const response = await this.axiosInstance.get(
        `/anime/season/${year}/${season}`,
        {
          params: {
            limit: limit,
            fields:
              "id,title,main_picture,mean,rank,popularity,num_episodes,media_type,status,genres,start_season,studios",
          },
        }
      );

      logger.info(
        "MAL API",
        `ƒê√£ l·∫•y ${response.data.data.length} k·∫øt qu·∫£ cho anime m√πa ${season} nƒÉm ${year}`
      );
      return response.data.data;
    } catch (error) {
      logger.error(
        "MAL API",
        `L·ªói khi l·∫•y anime m√πa ${season} nƒÉm ${year}:`,
        error.message
      );
      return [];
    }
  }

  /**
   * T√¨m ki·∫øm manga d·ª±a tr√™n t·ª´ kh√≥a
   * @param {string} query - T·ª´ kh√≥a t√¨m ki·∫øm
   * @param {number} limit - Gi·ªõi h·∫°n k·∫øt qu·∫£ (t·ªëi ƒëa 100)
   * @returns {Promise<Array>} - Danh s√°ch manga
   */
  async searchManga(query, limit = 10) {
    try {
      logger.info("MAL API", `ƒêang t√¨m ki·∫øm manga v·ªõi t·ª´ kh√≥a: "${query}"`);

      const response = await this.axiosInstance.get("/manga", {
        params: {
          q: query,
          limit: limit,
          fields:
            "id,title,main_picture,synopsis,mean,rank,popularity,num_volumes,num_chapters,media_type,status,genres",
        },
      });

      logger.info(
        "MAL API",
        `ƒê√£ t√¨m th·∫•y ${response.data.data.length} k·∫øt qu·∫£ cho "${query}"`
      );
      return response.data.data;
    } catch (error) {
      logger.error("MAL API", "L·ªói khi t√¨m ki·∫øm manga:", error.message);
      return [];
    }
  }

  /**
   * L·∫•y th√¥ng tin chi ti·∫øt v·ªÅ manga
   * @param {number} mangaId - ID c·ªßa manga
   * @returns {Promise<Object>} - Chi ti·∫øt manga
   */
  async getMangaDetails(mangaId) {
    try {
      logger.info(
        "MAL API",
        `ƒêang l·∫•y th√¥ng tin chi ti·∫øt c·ªßa manga ID: ${mangaId}`
      );

      const response = await this.axiosInstance.get(`/manga/${mangaId}`, {
        params: {
          fields:
            "id,title,main_picture,alternative_titles,start_date,end_date,synopsis,mean,rank,popularity,num_list_users,num_scoring_users,nsfw,created_at,updated_at,media_type,status,genres,my_list_status,num_volumes,num_chapters,authors{first_name,last_name},pictures,background,related_anime,related_manga,recommendations,serialization{name}",
        },
      });

      logger.info(
        "MAL API",
        `ƒê√£ l·∫•y th√¥ng tin chi ti·∫øt c·ªßa manga: ${response.data.title}`
      );
      return response.data;
    } catch (error) {
      logger.error(
        "MAL API",
        `L·ªói khi l·∫•y th√¥ng tin chi ti·∫øt manga ID ${mangaId}:`,
        error.message
      );
      return null;
    }
  }

  /**
   * L·∫•y b·∫£ng x·∫øp h·∫°ng manga
   * @param {string} rankingType - Lo·∫°i b·∫£ng x·∫øp h·∫°ng (all, manga, novels, oneshots, doujin, manhwa, manhua, bypopularity, favorite)
   * @param {number} limit - Gi·ªõi h·∫°n k·∫øt qu·∫£ (t·ªëi ƒëa 500)
   * @returns {Promise<Array>} - Danh s√°ch manga trong b·∫£ng x·∫øp h·∫°ng
   */
  async getMangaRanking(rankingType = "all", limit = 10) {
    try {
      logger.info(
        "MAL API",
        `ƒêang l·∫•y b·∫£ng x·∫øp h·∫°ng manga lo·∫°i: ${rankingType}`
      );

      const response = await this.axiosInstance.get("/manga/ranking", {
        params: {
          ranking_type: rankingType,
          limit: limit,
          fields:
            "id,title,main_picture,mean,rank,popularity,num_volumes,num_chapters,media_type,status",
        },
      });

      logger.info(
        "MAL API",
        `ƒê√£ l·∫•y ${response.data.data.length} k·∫øt qu·∫£ t·ª´ b·∫£ng x·∫øp h·∫°ng ${rankingType}`
      );
      return response.data.data;
    } catch (error) {
      logger.error(
        "MAL API",
        `L·ªói khi l·∫•y b·∫£ng x·∫øp h·∫°ng manga lo·∫°i ${rankingType}:`,
        error.message
      );
      return [];
    }
  }

  /**
   * T·∫°o Discord Embed cho k·∫øt qu·∫£ t√¨m ki·∫øm anime
   * @param {Array} animeList - Danh s√°ch anime
   * @param {string} query - T·ª´ kh√≥a t√¨m ki·∫øm
   * @returns {MessageEmbed} - Discord embed
   */
  createAnimeSearchEmbed(animeList, query) {
    const embed = {
      color: 0x2e51a2, // M√†u xanh c·ªßa MyAnimeList
      title: `K·∫øt qu·∫£ t√¨m ki·∫øm anime cho "${query}"`,
      footer: {
        text: "Powered by MyAnimeList API",
      },
      timestamp: new Date(),
      fields: [],
    };

    if (animeList.length === 0) {
      embed.description = "Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ n√†o.";
      return embed;
    }

    // L·∫•y t·ªëi ƒëa 5 k·∫øt qu·∫£ ƒë·ªÉ hi·ªÉn th·ªã
    const topResults = animeList.slice(0, 5);

    // Th√™m thumbnail cho embed l√† ·∫£nh c·ªßa anime ƒë·∫ßu ti√™n
    if (topResults[0].node.main_picture) {
      embed.thumbnail = { url: topResults[0].node.main_picture.medium };
    }

    // Th√™m c√°c k·∫øt qu·∫£ v√†o embed
    topResults.forEach((item, index) => {
      const anime = item.node;
      let status = "N/A";
      switch (anime.status) {
        case "finished_airing":
          status = "ƒê√£ ho√†n th√†nh";
          break;
        case "currently_airing":
          status = "ƒêang ph√°t s√≥ng";
          break;
        case "not_yet_aired":
          status = "Ch∆∞a ph√°t s√≥ng";
          break;
      }

      let info = "";
      if (anime.mean) info += `‚≠ê ƒêi·ªÉm: ${anime.mean}/10\n`;
      if (anime.num_episodes) info += `üé¨ T·∫≠p: ${anime.num_episodes}\n`;
      info += `üì∫ Lo·∫°i: ${anime.media_type?.toUpperCase() || "N/A"}\n`;
      info += `üìÖ Tr·∫°ng th√°i: ${status}\n`;

      if (anime.genres && anime.genres.length > 0) {
        const genreList = anime.genres
          .map((g) => g.name)
          .slice(0, 3)
          .join(", ");
        info += `üè∑Ô∏è Th·ªÉ lo·∫°i: ${genreList}`;
      }

      embed.fields.push({
        name: `${index + 1}. ${anime.title}`,
        value: `${info}\nID: ${anime.id}`,
        inline: false,
      });
    });

    if (animeList.length > 5) {
      embed.fields.push({
        name: "V√† nhi·ªÅu h∆°n n·ªØa...",
        value: `T√¨m th·∫•y t·ªïng c·ªông ${animeList.length} k·∫øt qu·∫£.`,
        inline: false,
      });
    }

    return embed;
  }

  /**
   * T·∫°o Discord Embed cho chi ti·∫øt anime
   * @param {Object} anime - Chi ti·∫øt anime
   * @returns {MessageEmbed} - Discord embed
   */
  createAnimeDetailEmbed(anime) {
    if (!anime)
      return {
        color: 0xff0000,
        title: "L·ªói",
        description: "Kh√¥ng th·ªÉ t√¨m th·∫•y th√¥ng tin anime.",
        footer: { text: "Powered by MyAnimeList API" },
        timestamp: new Date(),
      };

    let status = "N/A";
    switch (anime.status) {
      case "finished_airing":
        status = "ƒê√£ ho√†n th√†nh";
        break;
      case "currently_airing":
        status = "ƒêang ph√°t s√≥ng";
        break;
      case "not_yet_aired":
        status = "Ch∆∞a ph√°t s√≥ng";
        break;
    }

    // R√∫t g·ªçn synopsis n·∫øu qu√° d√†i
    let synopsis = anime.synopsis || "Kh√¥ng c√≥ m√¥ t·∫£.";
    if (synopsis.length > 500) {
      synopsis = synopsis.substring(0, 500) + "...";
    }

    const embed = {
      color: 0x2e51a2,
      title: anime.title,
      url: `https://myanimelist.net/anime/${anime.id}`,
      description: synopsis,
      thumbnail: anime.main_picture ? { url: anime.main_picture.medium } : null,
      fields: [
        {
          name: "üìä Th·ªëng k√™",
          value: `‚≠ê ƒêi·ªÉm: ${anime.mean || "N/A"}/10\nüèÜ X·∫øp h·∫°ng: #${
            anime.rank || "N/A"
          }\n‚ù§Ô∏è ƒê·ªô ph·ªï bi·∫øn: #${anime.popularity || "N/A"}\nüë• Ng∆∞·ªùi d√πng: ${
            anime.num_list_users?.toLocaleString() || "N/A"
          }`,
          inline: true,
        },
        {
          name: "üìù Th√¥ng tin",
          value: `üì∫ Lo·∫°i: ${
            anime.media_type?.toUpperCase() || "N/A"
          }\nüé¨ S·ªë t·∫≠p: ${
            anime.num_episodes || "N/A"
          }\nüìÖ Tr·∫°ng th√°i: ${status}\n‚åõ Th·ªùi l∆∞·ª£ng: ${
            anime.average_episode_duration
              ? Math.floor(anime.average_episode_duration / 60) + " ph√∫t"
              : "N/A"
          }`,
          inline: true,
        },
      ],
      footer: {
        text: "Powered by MyAnimeList API",
      },
      timestamp: new Date(),
    };

    // Th√™m th√¥ng tin m√πa
    if (anime.start_season) {
      let season = "";
      switch (anime.start_season.season) {
        case "winter":
          season = "ƒê√¥ng";
          break;
        case "spring":
          season = "Xu√¢n";
          break;
        case "summer":
          season = "H·∫°";
          break;
        case "fall":
          season = "Thu";
          break;
      }
      embed.fields.push({
        name: "üóìÔ∏è M√πa",
        value: `${season} ${anime.start_season.year}`,
        inline: true,
      });
    }

    // Th√™m th√¥ng tin studio
    if (anime.studios && anime.studios.length > 0) {
      const studioNames = anime.studios.map((s) => s.name).join(", ");
      embed.fields.push({
        name: "üè¢ Studio",
        value: studioNames,
        inline: true,
      });
    }

    // Th√™m th√¥ng tin th·ªÉ lo·∫°i
    if (anime.genres && anime.genres.length > 0) {
      const genreList = anime.genres.map((g) => g.name).join(", ");
      embed.fields.push({
        name: "üè∑Ô∏è Th·ªÉ lo·∫°i",
        value: genreList,
        inline: false,
      });
    }

    return embed;
  }

  /**
   * T·∫°o Discord Embed cho b·∫£ng x·∫øp h·∫°ng anime
   * @param {Array} rankingList - Danh s√°ch anime trong b·∫£ng x·∫øp h·∫°ng
   * @param {string} rankingType - Lo·∫°i b·∫£ng x·∫øp h·∫°ng
   * @returns {MessageEmbed} - Discord embed
   */
  createAnimeRankingEmbed(rankingList, rankingType) {
    const rankingTitles = {
      all: "Top Anime",
      airing: "Top Anime ƒêang Ph√°t S√≥ng",
      upcoming: "Top Anime S·∫Øp Ra M·∫Øt",
      tv: "Top Anime TV Series",
      ova: "Top Anime OVA",
      movie: "Top Anime Movie",
      special: "Top Anime Special",
      bypopularity: "Top Anime Theo ƒê·ªô Ph·ªï Bi·∫øn",
      favorite: "Top Anime ƒê∆∞·ª£c Y√™u Th√≠ch",
    };

    const embed = {
      color: 0x2e51a2,
      title: rankingTitles[rankingType] || `Top Anime - ${rankingType}`,
      footer: {
        text: "Powered by MyAnimeList API",
      },
      timestamp: new Date(),
      fields: [],
    };

    if (!rankingList || rankingList.length === 0) {
      embed.description = "Kh√¥ng c√≥ d·ªØ li·ªáu b·∫£ng x·∫øp h·∫°ng.";
      return embed;
    }

    // Ch·ªâ l·∫•y 5 k·∫øt qu·∫£ ƒë·∫ßu ƒë·ªÉ tr√°nh l·ªói
    const topResults = rankingList.slice(0, 5);

    // Th√™m thumbnail cho embed l√† ·∫£nh c·ªßa anime ƒë·∫ßu ti√™n
    if (topResults[0]?.node?.main_picture) {
      embed.thumbnail = { url: topResults[0].node.main_picture.medium };
    }

    // Log d·ªØ li·ªáu ƒë·ªÉ debug
    logger.info(
      "MAL API",
      `T·∫°o embed cho ${topResults.length} k·∫øt qu·∫£ ranking`
    );

    // Th√™m c√°c k·∫øt qu·∫£ v√†o embed
    topResults.forEach((item, index) => {
      if (!item || typeof item !== "object") {
        logger.warn(
          "MAL API",
          `Ph·∫ßn t·ª≠ kh√¥ng h·ª£p l·ªá ·ªü v·ªã tr√≠ ${index}: ${JSON.stringify(item)}`
        );
        return;
      }

      // Ki·ªÉm tra v√† truy c·∫≠p an to√†n
      const anime = item.node || {};
      const ranking = item.ranking || index + 1;

      // ƒê·∫£m b·∫£o title lu√¥n c√≥ gi√° tr·ªã
      const title = anime.title || "Kh√¥ng c√≥ ti√™u ƒë·ªÅ";

      let info = "";
      if (anime.mean) info += `‚≠ê ƒêi·ªÉm: ${anime.mean}/10\n`;
      if (anime.num_episodes) info += `üé¨ T·∫≠p: ${anime.num_episodes}\n`;
      if (anime.media_type)
        info += `üì∫ Lo·∫°i: ${anime.media_type.toUpperCase()}\n`;

      // Th√™m ID n·∫øu c√≥
      if (anime.id) {
        info += `üîó https://myanimelist.net/anime/${anime.id}`;
      }

      embed.fields.push({
        name: `${ranking}. ${title}`,
        value: info || "Kh√¥ng c√≥ th√¥ng tin",
        inline: false,
      });
    });

    return embed;
  }

  /**
   * T·∫°o Discord Embed cho k·∫øt qu·∫£ t√¨m ki·∫øm manga
   * @param {Array} mangaList - Danh s√°ch manga
   * @param {string} query - T·ª´ kh√≥a t√¨m ki·∫øm
   * @returns {MessageEmbed} - Discord embed
   */
  createMangaSearchEmbed(mangaList, query) {
    const embed = {
      color: 0x2e51a2,
      title: `K·∫øt qu·∫£ t√¨m ki·∫øm manga cho "${query}"`,
      footer: {
        text: "Powered by MyAnimeList API",
      },
      timestamp: new Date(),
      fields: [],
    };

    if (mangaList.length === 0) {
      embed.description = "Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ n√†o.";
      return embed;
    }

    // L·∫•y t·ªëi ƒëa 5 k·∫øt qu·∫£ ƒë·ªÉ hi·ªÉn th·ªã
    const topResults = mangaList.slice(0, 5);

    // Th√™m thumbnail cho embed l√† ·∫£nh c·ªßa manga ƒë·∫ßu ti√™n
    if (topResults[0].node.main_picture) {
      embed.thumbnail = { url: topResults[0].node.main_picture.medium };
    }

    // Th√™m c√°c k·∫øt qu·∫£ v√†o embed
    topResults.forEach((item, index) => {
      const manga = item.node;
      let status = "N/A";
      switch (manga.status) {
        case "finished":
          status = "ƒê√£ ho√†n th√†nh";
          break;
        case "currently_publishing":
          status = "ƒêang xu·∫•t b·∫£n";
          break;
        case "not_yet_published":
          status = "Ch∆∞a xu·∫•t b·∫£n";
          break;
      }

      let info = "";
      if (manga.mean) info += `‚≠ê ƒêi·ªÉm: ${manga.mean}/10\n`;
      if (manga.num_volumes) info += `üìö T·∫≠p: ${manga.num_volumes}\n`;
      if (manga.num_chapters) info += `üìë Ch∆∞∆°ng: ${manga.num_chapters}\n`;
      info += `üìÖ Tr·∫°ng th√°i: ${status}\n`;

      if (manga.genres && manga.genres.length > 0) {
        const genreList = manga.genres
          .map((g) => g.name)
          .slice(0, 3)
          .join(", ");
        info += `üè∑Ô∏è Th·ªÉ lo·∫°i: ${genreList}`;
      }

      embed.fields.push({
        name: `${index + 1}. ${manga.title}`,
        value: `${info}\nID: ${manga.id}`,
        inline: false,
      });
    });

    if (mangaList.length > 5) {
      embed.fields.push({
        name: "V√† nhi·ªÅu h∆°n n·ªØa...",
        value: `T√¨m th·∫•y t·ªïng c·ªông ${mangaList.length} k·∫øt qu·∫£.`,
        inline: false,
      });
    }

    return embed;
  }

  /**
   * T·∫°o Discord Embed cho chi ti·∫øt manga
   * @param {Object} manga - Chi ti·∫øt manga
   * @returns {MessageEmbed} - Discord embed
   */
  createMangaDetailEmbed(manga) {
    if (!manga)
      return {
        color: 0xff0000,
        title: "L·ªói",
        description: "Kh√¥ng th·ªÉ t√¨m th·∫•y th√¥ng tin manga.",
        footer: { text: "Powered by MyAnimeList API" },
        timestamp: new Date(),
      };

    let status = "N/A";
    switch (manga.status) {
      case "finished":
        status = "ƒê√£ ho√†n th√†nh";
        break;
      case "currently_publishing":
        status = "ƒêang xu·∫•t b·∫£n";
        break;
      case "not_yet_published":
        status = "Ch∆∞a xu·∫•t b·∫£n";
        break;
    }

    // R√∫t g·ªçn synopsis n·∫øu qu√° d√†i
    let synopsis = manga.synopsis || "Kh√¥ng c√≥ m√¥ t·∫£.";
    if (synopsis.length > 500) {
      synopsis = synopsis.substring(0, 500) + "...";
    }

    const embed = {
      color: 0x2e51a2,
      title: manga.title,
      url: `https://myanimelist.net/manga/${manga.id}`,
      description: synopsis,
      thumbnail: manga.main_picture ? { url: manga.main_picture.medium } : null,
      fields: [
        {
          name: "üìä Th·ªëng k√™",
          value: `‚≠ê ƒêi·ªÉm: ${manga.mean || "N/A"}/10\nüèÜ X·∫øp h·∫°ng: #${
            manga.rank || "N/A"
          }\n‚ù§Ô∏è ƒê·ªô ph·ªï bi·∫øn: #${manga.popularity || "N/A"}\nüë• Ng∆∞·ªùi d√πng: ${
            manga.num_list_users?.toLocaleString() || "N/A"
          }`,
          inline: true,
        },
        {
          name: "üìù Th√¥ng tin",
          value: `üìö T·∫≠p: ${manga.num_volumes || "N/A"}\nüìë Ch∆∞∆°ng: ${
            manga.num_chapters || "N/A"
          }\nüìÖ Tr·∫°ng th√°i: ${status}`,
          inline: true,
        },
      ],
      footer: {
        text: "Powered by MyAnimeList API",
      },
      timestamp: new Date(),
    };

    // Th√™m th√¥ng tin t√°c gi·∫£
    if (manga.authors && manga.authors.length > 0) {
      const authorNames = manga.authors
        .map((a) => `${a.node.first_name} ${a.node.last_name}`)
        .join(", ");
      embed.fields.push({
        name: "‚úçÔ∏è T√°c gi·∫£",
        value: authorNames,
        inline: true,
      });
    }

    // Th√™m th√¥ng tin th·ªÉ lo·∫°i
    if (manga.genres && manga.genres.length > 0) {
      const genreList = manga.genres.map((g) => g.name).join(", ");
      embed.fields.push({
        name: "üè∑Ô∏è Th·ªÉ lo·∫°i",
        value: genreList,
        inline: false,
      });
    }

    return embed;
  }
}

module.exports = new MyAnimeListAPI();
