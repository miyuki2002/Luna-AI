const logger = require("../utils/logger.js");
const AICore = require("./AICore.js");
const prompts = require("../config/prompts.js");

class OwnerService {
  constructor() {
    this.ownerId = process.env.OWNER_ID;
    this.ownerInfo = null;
    this.client = null;
  }

  /**
   * Kh·ªüi t·∫°o service v·ªõi Discord client
   * @param {Client} client - Discord client
   */
  initialize(client) {
    this.client = client;
    this.loadOwnerInfo();
  }

  /**
   * T·∫£i th√¥ng tin owner t·ª´ Discord API
   */
  async loadOwnerInfo() {
    if (!this.ownerId || !this.client) {
      logger.warn(
        "OWNER",
        "OWNER_ID kh√¥ng ƒë∆∞·ª£c thi·∫øt l·∫≠p ho·∫∑c client ch∆∞a s·∫µn s√†ng"
      );
      return;
    }

    try {
      const owner = await this.client.users.fetch(this.ownerId);
      this.ownerInfo = {
        id: owner.id,
        username: owner.username,
        displayName: owner.displayName || owner.username,
        tag: owner.tag,
        avatar: owner.displayAvatarURL({ dynamic: true, size: 512 }),
      };

      logger.info(
        "OWNER",
        `ƒê√£ t·∫£i th√¥ng tin owner: ${this.ownerInfo.username} (${this.ownerInfo.id})`
      );
    } catch (error) {
      logger.error("OWNER", "L·ªói khi t·∫£i th√¥ng tin owner:", error);
    }
  }

  /**
   * Ki·ªÉm tra xem user ID c√≥ ph·∫£i l√† owner kh√¥ng
   * @param {string} userId - ID c·ªßa user c·∫ßn ki·ªÉm tra
   * @returns {boolean}
   */
  isOwner(userId) {
    return userId === this.ownerId;
  }

  /**
   * L·∫•y th√¥ng tin owner
   * @returns {Object|null}
   */
  getOwnerInfo() {
    return this.ownerInfo;
  }

  /**
   * Ki·ªÉm tra xem tin nh·∫Øn c√≥ nh·∫Øc ƒë·∫øn owner kh√¥ng (b·∫±ng ID ho·∫∑c username)
   * @param {string} content - N·ªôi dung tin nh·∫Øn
   * @param {Object} message - ƒê·ªëi t∆∞·ª£ng tin nh·∫Øn Discord (ƒë·ªÉ ki·ªÉm tra mentions)
   * @returns {boolean}
   */
  isOwnerMentioned(content, message = null) {
    if (!this.ownerInfo) return false;

    // Ki·ªÉm tra mention tr·ª±c ti·∫øp qua Discord
    if (
      message &&
      message.mentions &&
      message.mentions.users.has(this.ownerId)
    ) {
      return true;
    }

    // Ki·ªÉm tra mention b·∫±ng ID trong text
    const idMentionRegex = new RegExp(`<@!?${this.ownerId}>`, "i");
    if (idMentionRegex.test(content)) {
      return true;
    }

    // Ki·ªÉm tra nh·∫Øc ƒë·∫øn username (kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng)
    const usernameRegex = new RegExp(`\\b${this.ownerInfo.username}\\b`, "i");
    if (usernameRegex.test(content)) {
      return true;
    }

    // Ki·ªÉm tra c√°c t·ª´ kh√≥a li√™n quan ƒë·∫øn owner
    const ownerKeywords = [
      "owner",
      "ch·ªß s·ªü h·ªØu",
      "ng∆∞·ªùi s√°ng l·∫≠p",
      "creator",
      "developer",
      "dev",
      "ng∆∞·ªùi t·∫°o",
      "ng∆∞·ªùi ph√°t tri·ªÉn",
      "admin ch√≠nh",
      "boss",
    ];

    const contentLower = content.toLowerCase();
    return ownerKeywords.some((keyword) => contentLower.includes(keyword));
  }

  /**
   * T·∫°o tin nh·∫Øn khi owner ƒë∆∞·ª£c nh·∫Øc ƒë·∫øn
   * @param {string} context - Ng·ªØ c·∫£nh c·ªßa cu·ªôc tr√≤ chuy·ªán
   * @returns {Promise<string>}
   */
  async getOwnerMentionResponse(context = "") {
    if (!this.ownerInfo) {
      return "B·∫°n ƒëang n√≥i v·ªÅ ng∆∞·ªùi s√°ng l·∫≠p c·ªßa m√¨nh √†? üòä M√¨nh r·∫•t y√™u qu√Ω creator c·ªßa m√¨nh l·∫Øm! ‚ú®";
    }

    try {
      const prompt = prompts.owner.mentionResponse
        .replace("${ownerUsername}", this.ownerInfo.username)
        .replace("${ownerDisplayName}", this.ownerInfo.displayName)
        .replace("${context}", context);

      const response = await AICore.getCompletion(prompt);
      return response;
    } catch (error) {
      logger.error(
        "OWNER",
        "L·ªói khi t·∫°o ph·∫£n h·ªìi ƒë·ªông cho owner mention:",
        error
      );
      // Fallback response v·ªõi personality m·ªõi
      return `Aww, b·∫°n ƒëang n√≥i v·ªÅ ${this.ownerInfo.displayName} √†? üíñ M√¨nh r·∫•t y√™u qu√Ω creator c·ªßa m√¨nh l·∫Øm! ‚ú®`;
    }
  }

  /**
   * T·∫°o l·ªùi ch√†o ƒë·∫∑c bi·ªát cho owner
   * @returns {Promise<string>}
   */
  async getOwnerGreeting() {
    if (!this.ownerInfo) {
      return "Ch√†o b·∫°n! üíñ H√¥m nay c√≥ g√¨ c·∫ßn m√¨nh gi√∫p kh√¥ng ·∫°? ‚ú®";
    }

    try {
      const prompt = prompts.owner.greeting.replace(
        "${ownerDisplayName}",
        this.ownerInfo.displayName
      );

      logger.info(
        "OWNER",
        `ƒêang t·∫°o l·ªùi ch√†o ƒë·∫∑c bi·ªát cho owner: ${this.ownerInfo.displayName}`
      );
      const response = await AICore.getCompletion(prompt);
      return response;
    } catch (error) {
      logger.error("OWNER", "L·ªói khi t·∫°o l·ªùi ch√†o ƒë·ªông cho owner:", error);
      
      // Fallback: S·ª≠ d·ª•ng AI v·ªõi prompt ƒë∆°n gi·∫£n h∆°n
      try {
        const fallbackPrompt = `T·∫°o l·ªùi ch√†o th√¢n thi·ªán cho ${this.ownerInfo.displayName} - creator c·ªßa m√¨nh. Ng·∫Øn g·ªçn, d·ªÖ th∆∞∆°ng, s·ª≠ d·ª•ng emoji.`;
        const fallbackResponse = await AICore.getCompletion(fallbackPrompt);
        return fallbackResponse;
      } catch (fallbackError) {
        logger.error("OWNER", "Fallback AI greeting c≈©ng l·ªói:", fallbackError);
        
        // Final fallback: greetings c√≥ s·∫µn
        const greetings = [
          `${this.ownerInfo.displayName}! üíñ M√¨nh nh·ªõ b·∫°n qu√°~ ‚ú®`,
          `Creator ${this.ownerInfo.displayName}! üå∏ R·∫•t vui khi g·∫∑p l·∫°i b·∫°n! üí´`,
          `${this.ownerInfo.displayName} ∆°i! ü•∞ M√¨nh ƒë√£ ch·ªù b·∫°n l√¢u r·ªìi! üåü`,
          `Aww, ${this.ownerInfo.displayName}! üíñ B·∫°n c√≥ kh·ªèe kh√¥ng? ‚ú®`,
          `Hello ${this.ownerInfo.displayName}! üéÄ M√¨nh s·∫µn s√†ng gi√∫p b·∫°n r·ªìi! üí´`
        ];
        return greetings[Math.floor(Math.random() * greetings.length)];
      }
    }
  }

  /**
   * Refresh th√¥ng tin owner (g·ªçi l·∫°i API Discord)
   */
  async refreshOwnerInfo() {
    await this.loadOwnerInfo();
  }

  /**
   * T·∫°o ph·∫£n h·ªìi AI cho owner d·ª±a tr√™n context
   * @param {string} context - Ng·ªØ c·∫£nh c·ªßa cu·ªôc tr√≤ chuy·ªán
   * @param {string} type - Lo·∫°i ph·∫£n h·ªìi (greeting, mention, notification, etc.)
   * @returns {Promise<string>}
   */
  async getAIOwnerResponse(context = "", type = "general") {
    if (!this.ownerInfo) {
      return "Ch√†o b·∫°n! üíñ";
    }

    try {
      let prompt = "";
      
      switch (type) {
        case "greeting":
          prompt = prompts.owner.greeting
            .replace("${ownerDisplayName}", this.ownerInfo.displayName);
          break;
        case "mention":
          prompt = prompts.owner.mentionResponse
            .replace("${ownerDisplayName}", this.ownerInfo.displayName)
            .replace("${ownerUsername}", this.ownerInfo.username)
            .replace("${context}", context);
          break;
        case "notification":
          prompt = prompts.owner.notification
            .replace("${ownerDisplayName}", this.ownerInfo.displayName)
            .replace("${context}", context);
          break;
        case "celebration":
          prompt = prompts.owner.celebration
            .replace("${ownerDisplayName}", this.ownerInfo.displayName)
            .replace("${context}", context);
          break;
        default:
          prompt = prompts.owner.general
            .replace("${ownerDisplayName}", this.ownerInfo.displayName)
            .replace("${context}", context);
      }

      const response = await AICore.getCompletion(prompt);
      return response;
    } catch (error) {
      logger.error("OWNER", `L·ªói khi t·∫°o AI response cho owner (${type}):`, error);
      
      // Fallback responses
      const fallbacks = {
        greeting: `${this.ownerInfo.displayName}! üíñ M√¨nh nh·ªõ b·∫°n qu√°~ ‚ú®`,
        mention: `Aww, b·∫°n ƒëang n√≥i v·ªÅ ${this.ownerInfo.displayName} √†? üíñ M√¨nh r·∫•t y√™u qu√Ω creator c·ªßa m√¨nh l·∫Øm! ‚ú®`,
        notification: `üîî **Th√¥ng b√°o cho ${this.ownerInfo.displayName}:**\n${context} üíñ`,
        celebration: `üéâ Ch√∫c m·ª´ng ${this.ownerInfo.displayName}! üíñ M√¨nh r·∫•t vui cho b·∫°n! ‚ú®`,
        general: `${this.ownerInfo.displayName}! üíñ M√¨nh lu√¥n s·∫µn s√†ng gi√∫p b·∫°n! ‚ú®`
      };
      
      return fallbacks[type] || fallbacks.general;
    }
  }

  /**
   * Ki·ªÉm tra xem owner c√≥ online kh√¥ng
   * @returns {Promise<boolean>}
   */
  async isOwnerOnline() {
    if (!this.ownerInfo || !this.client) return false;
    
    try {
      const owner = await this.client.users.fetch(this.ownerId);
      return owner.presence?.status !== 'offline';
    } catch (error) {
      logger.error("OWNER", "L·ªói khi ki·ªÉm tra tr·∫°ng th√°i owner:", error);
      return false;
    }
  }

  /**
   * T·∫°o th√¥ng b√°o ƒë·∫∑c bi·ªát cho owner
   * @param {string} message - N·ªôi dung th√¥ng b√°o
   * @returns {string}
   */
  getOwnerNotification(message) {
    if (!this.ownerInfo) {
      return `üîî Th√¥ng b√°o: ${message}`;
    }
    
    return `üîî **Th√¥ng b√°o cho ${this.ownerInfo.displayName}:**\n${message} üíñ`;
  }

  /**
   * T·∫°o l·ªùi ch√†o ng·∫´u nhi√™n cho owner b·∫±ng AI
   * @returns {Promise<string>}
   */
  async getRandomOwnerGreeting() {
    if (!this.ownerInfo) {
      return "Ch√†o b·∫°n! üíñ";
    }

    try {
      const prompt = prompts.owner.randomGreeting
        .replace("${ownerDisplayName}", this.ownerInfo.displayName);

      const response = await AICore.getCompletion(prompt);
      return response;
    } catch (error) {
      logger.error("OWNER", "L·ªói khi t·∫°o l·ªùi ch√†o AI cho owner:", error);
      
      // Fallback greetings n·∫øu AI l·ªói
      const greetings = [
        `${this.ownerInfo.displayName}! üíñ M√¨nh nh·ªõ b·∫°n qu√°~ ‚ú®`,
        `Creator ${this.ownerInfo.displayName}! üå∏ R·∫•t vui khi g·∫∑p l·∫°i b·∫°n! üí´`,
        `${this.ownerInfo.displayName} ∆°i! ü•∞ M√¨nh ƒë√£ ch·ªù b·∫°n l√¢u r·ªìi! üåü`,
        `Aww, ${this.ownerInfo.displayName}! üíñ B·∫°n c√≥ kh·ªèe kh√¥ng? ‚ú®`,
        `Hello daddy ${this.ownerInfo.displayName}! üéÄ M√¨nh s·∫µn s√†ng gi√∫p b·∫°n r·ªìi! üí´`,
        `${this.ownerInfo.displayName} √†! üå∏ M√¨nh r·∫•t vui khi th·∫•y b·∫°n! ‚ú®`,
        `üíñ ${this.ownerInfo.displayName} c√≥ c·∫ßn m√¨nh gi√∫p g√¨ kh√¥ng? üåü`,
        `Creator ${this.ownerInfo.displayName}! üí´ M√¨nh ƒë√£ s·∫µn s√†ng ph·ª•c v·ª• b·∫°n r·ªìi! üéÄ`
      ];
      
      return greetings[Math.floor(Math.random() * greetings.length)];
    }
  }
}

// Export singleton instance
module.exports = new OwnerService();
